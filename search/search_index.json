{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Python CQRS <p>Modern CQRS pattern implementation with Transaction Outbox support</p> \ud83d\udc19 GitHub \ud83d\udce6 PyPI \ud83d\udcca Downloads"},{"location":"#what-is-it","title":"What is it?","text":"<p>Python CQRS is a framework for implementing the CQRS (Command Query Responsibility Segregation) pattern in Python applications. It helps separate read and write operations, improving scalability, performance, and code maintainability.</p>"},{"location":"#key-benefits","title":"Key Benefits","text":"<ul> <li>\ud83d\ude80 Performance \u2014 separation of commands and queries</li> <li>\ud83d\udd12 Reliability \u2014 Transaction Outbox for guaranteed event delivery</li> <li>\ud83c\udfaf Type Safety \u2014 full Pydantic v2 support</li> <li>\ud83d\udd0c Integrations \u2014 FastAPI, FastStream, Kafka out of the box</li> <li>\u26a1 Simplicity \u2014 bootstrap for quick setup</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#installation","title":"Installation","text":"<pre><code>pip install python-cqrs\n</code></pre>"},{"location":"#basic-example","title":"Basic Example","text":"<pre><code>import cqrs\nfrom cqrs.events import Event\nfrom datetime import datetime\n\nclass CreateUserCommand(cqrs.Request): # (1)\n    email: str\n    name: str\n\nclass GetUserQuery(cqrs.Request):\n    user_id: str\n\nclass CreateUserResponse(cqrs.Response): # (2)\n    user_id: str\n    email: str\n    name: str\n\nclass GetUserResponse(cqrs.Response):\n    user_id: str\n    email: str\n    name: str\n    created_at: str\n\nclass UserCreatedEvent(Event): # (3)\n    user_id: str\n    email: str\n    name: str\n    created_at: datetime\n\nclass CreateUserHandler(cqrs.RequestHandler[CreateUserCommand, CreateUserResponse]): # (4)\n    def __init__(self):\n        self._events: list[Event] = [] # (5)\n\n    @property\n    def events(self) -&gt; list[Event]:\n        return self._events # (6)\n\n    async def handle(self, request: CreateUserCommand) -&gt; CreateUserResponse:\n        user_id = f\"user_{request.email}\" # (7)\n\n        self._events.append(UserCreatedEvent( # (9)\n            user_id=user_id,\n            email=request.email,\n            name=request.name,\n            created_at=datetime.utcnow()\n        ))\n\n        return CreateUserResponse(\n            user_id=user_id,\n            email=request.email,\n            name=request.name\n        )\n\nclass GetUserHandler(cqrs.RequestHandler[GetUserQuery, GetUserResponse]):\n    @property\n    def events(self) -&gt; list[Event]:\n        return [] # (8)\n\n    async def handle(self, request: GetUserQuery) -&gt; GetUserResponse:\n        return GetUserResponse( # (10)\n            user_id=request.user_id,\n            email=\"user@example.com\",\n            name=\"John Doe\",\n            created_at=\"2024-01-01T00:00:00Z\"\n        )\n\nclass UserCreatedEventHandler(cqrs.EventHandler[UserCreatedEvent]): # (11)\n    async def handle(self, event: UserCreatedEvent) -&gt; None:\n        print(f\"User created: {event.name} ({event.email}) with ID: {event.user_id}\") # (12)\n\nmediator = cqrs.bootstrap.bootstrap( # (13)\n    commands_mapper=lambda m: m.bind(CreateUserCommand, CreateUserHandler),\n    queries_mapper=lambda m: m.bind(GetUserQuery, GetUserHandler),\n    domain_events_mapper=lambda m: m.bind(UserCreatedEvent, UserCreatedEventHandler)\n)\n\nresult = await mediator.send(CreateUserCommand( # (14)\n    email=\"user@example.com\",\n    name=\"John Doe\"\n))\n\nuser_data = await mediator.send(GetUserQuery( # (15)\n    user_id=\"user_user@example.com\"\n))\n</code></pre> <ol> <li> <p>Commands and Queries: Commands modify system state, queries read data. Both inherit from <code>cqrs.Request</code>.</p> </li> <li> <p>Response Classes: Response classes inherit from <code>cqrs.Response</code> and define the structure of returned data.</p> </li> <li> <p>Events: Events inherit from <code>cqrs.events.Event</code> and represent domain events that occurred.</p> </li> <li> <p>Handlers: Command Handler modifies state and can emit events. Query Handler reads data and typically doesn't emit events. Both must implement the <code>events</code> property</p> </li> <li> <p>Event Storage: Command handlers store events in <code>_events</code> list to emit them after processing.</p> </li> <li> <p>Events Property: Required by <code>RequestHandler</code> interface to access emitted events.</p> </li> <li> <p>Business Logic: Generate unique identifiers and perform domain operations.</p> </li> <li> <p>Query Events: Queries typically don't emit events as they only read data.</p> </li> <li> <p>Event Emission: Command handlers emit domain events by adding them to the <code>_events</code> list.</p> </li> <li> <p>Read Model: Query handlers fetch data from read models optimized for specific queries.</p> </li> <li> <p>Event Handler: Event handlers process domain events and handle side effects like notifications or read model updates.</p> </li> <li> <p>Side Effects: Event handlers handle side effects such as sending notifications, updating read models, or triggering other processes.</p> </li> <li> <p>Mediator Configuration: Bootstrap creates the mediator with command, query, and event mappings.</p> </li> <li> <p>Usage: Commands modify state and may emit events</p> </li> <li> <p>Usage: Queries read data without side effects</p> </li> </ol>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#cqrs-pattern","title":"\ud83c\udfaf CQRS Pattern","text":"<ul> <li>Clear separation of commands and queries</li> <li>Independent scaling of read/write models</li> <li>Optimization for specific use cases</li> </ul>"},{"location":"#transaction-outbox","title":"\ud83d\udce6 Transaction Outbox","text":"<ul> <li>Guaranteed event delivery</li> <li>Kafka, RabbitMQ support</li> <li>Automatic failure handling</li> </ul>"},{"location":"#ready-integrations","title":"\ud83d\udd0c Ready Integrations","text":"<ul> <li>FastAPI \u2014 HTTP API endpoints</li> <li>FastStream \u2014 Kafka event processing</li> <li>Kafka \u2014 via aiokafka</li> <li>Pydantic v2 \u2014 data validation</li> </ul>"},{"location":"#bootstrap","title":"\u2699\ufe0f Bootstrap","text":"<ul> <li>Automatic DI container setup</li> <li>Command, query, and event mapping</li> <li>Ready configurations for popular frameworks</li> </ul>"},{"location":"#architecture","title":"Architecture","text":"Request <p>Commands &amp; Queries</p> \u2192 RequestHandler <p>Execute business logic</p> \u2192 Event <p>Notify about changes</p> \u2192 EventHandler <p>Process side effects</p>"},{"location":"#fastapi-integration","title":"FastAPI Integration","text":"<pre><code>import fastapi\nimport cqrs\n\napp = fastapi.FastAPI()\n\n@app.post(\"/users\")\nasync def create_user(\n    command: CreateUserCommand,\n    mediator: cqrs.RequestMediator = fastapi.Depends(get_mediator)\n):\n    result = await mediator.send(command)\n    return {\"user_id\": result.data[\"user_id\"]}\n</code></pre>"},{"location":"#kafka-event-processing","title":"Kafka Event Processing","text":"<pre><code>import faststream\nfrom faststream import kafka\n\n@broker.subscriber(\"user_events\")\nasync def handle_user_event(\n    event: cqrs.NotificationEvent[UserCreatedPayload],\n    mediator: cqrs.EventMediator = faststream.Depends(get_mediator)\n):\n    await mediator.send(event)\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":""},{"location":"#core-concepts","title":"Core Concepts","text":"<ul> <li>Bootstrap \u2014 quick project setup</li> <li>Request Handlers \u2014 working with commands and queries</li> <li>Event Handling \u2014 event processing</li> <li>Transaction Outbox \u2014 reliable event delivery</li> </ul>"},{"location":"#integrations","title":"Integrations","text":"<ul> <li>FastAPI Integration \u2014 HTTP API</li> <li>FastStream Integration \u2014 Kafka events</li> <li>Dependency Injection \u2014 dependency management</li> <li>Kafka Integration \u2014 Kafka configuration</li> <li>Event Producing \u2014 event publishing</li> </ul>"},{"location":"#examples","title":"Examples","text":"<ul> <li>Examples \u2014 practical examples and tutorials</li> </ul>"},{"location":"#installation_1","title":"Installation","text":""},{"location":"#standard-installation","title":"Standard Installation","text":"<pre><code>pip install python-cqrs\n</code></pre>"},{"location":"#from-github","title":"From GitHub","text":"<pre><code>pip install git+https://github.com/vadikko2/python-cqrs\n</code></pre>"},{"location":"#using-uv","title":"Using uv","text":"<pre><code>uv add python-cqrs\n</code></pre>"},{"location":"#about","title":"About","text":"<p>This framework is developed by the Timeweb.Cloud development team.</p> <p>Built with \u2764\ufe0f by Timeweb.Cloud \u2014 your reliable cloud infrastructure partner.</p>"},{"location":"bootstrap/","title":"Bootstrap","text":""},{"location":"di/","title":"Dependency Injection","text":"<p>Dependency Injection (DI) is a design pattern that allows injecting dependencies into application components, simplifying their management and improving code testability.</p>"},{"location":"di/#overview","title":"Overview","text":"<p>The <code>python-cqrs</code> package uses the <code>di</code> library for dependency injection. This allows you to bind implementations to interfaces and automatically resolve dependencies in your handlers.</p>"},{"location":"di/#basic-setup","title":"Basic Setup","text":"<p>Here's how to set up a DI container with <code>python-cqrs</code>:</p> <pre><code>import di\nfrom di import Container\nfrom di.dependent import Dependent\nfrom cqrs import OutboxedEventRepository, SqlAlchemyOutboxedEventRepository\nfrom app.meeting_api import MeetingAPIImplementation, MeetingAPIProtocol\n\ndef setup_di() -&gt; Container:\n    \"\"\"\n    Setup DI container with implementation bindings.\n    \"\"\"\n    container = Container()\n\n    # Bind repository implementation\n    container.bind(\n        di.bind_by_type(\n            Dependent(SqlAlchemyOutboxedEventRepository, scope=\"request\"),\n            OutboxedEventRepository\n        )\n    )\n\n    # Bind service implementation\n    container.bind(\n        di.bind_by_type(\n            Dependent(MeetingAPIImplementation, scope=\"request\"),\n            MeetingAPIProtocol\n        )\n    )\n\n    return container\n</code></pre>"},{"location":"di/#using-di-with-bootstrap","title":"Using DI with Bootstrap","text":"<p>Once you have your DI container set up, you can use it with the bootstrap function:</p> <pre><code>import functools\nfrom cqrs.requests import bootstrap as request_bootstrap\nfrom app import dependencies, mapping, orm\n\n@functools.lru_cache\ndef mediator_factory():\n    return request_bootstrap.bootstrap(\n        di_container=dependencies.setup_di(),\n        commands_mapper=mapping.init_commands,\n        queries_mapper=mapping.init_queries,\n        domain_events_mapper=mapping.init_events,\n        on_startup=[orm.init_store_event_mapper],\n    )\n</code></pre>"},{"location":"di/#handler-with-dependencies","title":"Handler with Dependencies","text":"<p>Here's an example of a command handler that uses dependency injection:</p> <pre><code>from cqrs.requests import RequestHandler\nfrom cqrs.events import Event\nfrom app.meeting_api import MeetingAPIProtocol\n\nclass JoinMeetingCommandHandler(RequestHandler[JoinMeetingCommand, None]):\n\n    def __init__(self, meetings_api: MeetingAPIProtocol) -&gt; None:\n        self._meetings_api = meetings_api\n        self._events: list[Event] = []\n\n    @property\n    def events(self) -&gt; list[Event]:\n        return self._events\n\n    async def handle(self, request: JoinMeetingCommand) -&gt; None:\n        await self._meetings_api.join_user(request.user_id, request.meeting_id)\n\n        # Add domain event\n        self._events.append(\n            UserJoinedMeetingEvent(\n                user_id=request.user_id,\n                meeting_id=request.meeting_id\n            )\n        )\n</code></pre>"},{"location":"di/#scopes","title":"Scopes","text":"<p>The <code>di</code> library supports different scopes for dependency resolution:</p> <ul> <li><code>\"singleton\"</code>: One instance per container</li> <li><code>\"request\"</code>: One instance per request</li> <li><code>\"scoped\"</code>: One instance per scope</li> </ul> <pre><code># Singleton scope\ncontainer.bind(\n    di.bind_by_type(\n        Dependent(DatabaseConnection, scope=\"singleton\"),\n        DatabaseConnection\n    )\n)\n\n# Request scope\ncontainer.bind(\n    di.bind_by_type(\n        Dependent(UserService, scope=\"request\"),\n        UserService\n    )\n)\n</code></pre>"},{"location":"di/#advanced-configuration","title":"Advanced Configuration","text":"<p>For more complex scenarios, you can configure dependencies with additional parameters:</p> <pre><code>def setup_advanced_di() -&gt; Container:\n    container = Container()\n\n    # Bind with factory function\n    container.bind(\n        di.bind_by_type(\n            Dependent(\n                lambda: DatabaseConnection(\n                    host=\"localhost\",\n                    port=5432,\n                    database=\"myapp\"\n                ),\n                scope=\"singleton\"\n            ),\n            DatabaseConnection\n        )\n    )\n\n    # Bind with dependencies\n    container.bind(\n        di.bind_by_type(\n            Dependent(\n                UserService,\n                scope=\"request\",\n                use_cache=True\n            ),\n            UserService\n        )\n    )\n\n    return container\n</code></pre>"},{"location":"di/#testing-with-di","title":"Testing with DI","text":"<p>Dependency injection makes testing easier by allowing you to mock dependencies:</p> <pre><code>import pytest\nfrom unittest.mock import Mock\nfrom app.dependencies import setup_di\nfrom app.handlers import JoinMeetingCommandHandler\n\n@pytest.fixture\ndef mock_meeting_api():\n    return Mock(spec=MeetingAPIProtocol)\n\n@pytest.fixture\ndef test_container(mock_meeting_api):\n    container = setup_di()\n    container.bind(\n        di.bind_by_type(\n            Dependent(lambda: mock_meeting_api, scope=\"request\"),\n            MeetingAPIProtocol\n        )\n    )\n    return container\n\nasync def test_join_meeting_command(test_container, mock_meeting_api):\n    handler = test_container.solve(JoinMeetingCommandHandler)\n\n    command = JoinMeetingCommand(user_id=\"user1\", meeting_id=\"meeting1\")\n    await handler.handle(command)\n\n    mock_meeting_api.join_user.assert_called_once_with(\"user1\", \"meeting1\")\n</code></pre>"},{"location":"di/#benefits","title":"Benefits","text":"<p>Using dependency injection with <code>python-cqrs</code> provides several benefits:</p> <ol> <li>Simplified dependency management: The DI container handles creation and management of dependencies</li> <li>Improved testability: Easy to mock dependencies for unit testing</li> <li>Flexibility: Easy to swap implementations without changing core application code</li> <li>Better separation of concerns: Dependencies are explicitly declared and injected</li> <li>Configuration management: Centralized configuration of application dependencies</li> </ol>"},{"location":"di/#best-practices","title":"Best Practices","text":"<ol> <li>Use interfaces: Always bind implementations to interfaces, not concrete classes</li> <li>Choose appropriate scopes: Use singleton for stateless services, request for stateful ones</li> <li>Keep constructors simple: Avoid complex logic in constructors</li> <li>Use factory functions: For complex object creation, use factory functions</li> <li>Test with mocks: Always test your handlers with mocked dependencies</li> </ol>"},{"location":"event_consuming/","title":"Event Consuming","text":""},{"location":"event_producing/","title":"Event Producing","text":""},{"location":"fastapi/","title":"FastAPI integration","text":""},{"location":"faststream/","title":"Faststream integration","text":""},{"location":"kafka/","title":"Kafka integration","text":""},{"location":"outbox/","title":"Transactional Outbox","text":""},{"location":"request_handler/","title":"Request Handlers","text":"<p>Request handlers can be divided into two main types:</p> <ol> <li>Command Handler</li> <li>Query Handler</li> </ol>"},{"location":"request_handler/#command-handler","title":"Command Handler","text":"<p>Command Handler executes the received command. The logic of the handler may include, for example, modifying the state of the domain model. As a result of executing the command, an event may be produced to the broker.</p> Note <p>By default, the command handler does not return any result, but it is not mandatory.</p> <pre><code>from cqrs.requests.request_handler import RequestHandler, SyncRequestHandler\nfrom cqrs.events.event import Event\n\nclass JoinMeetingCommandHandler(RequestHandler[JoinMeetingCommand, None]):\n\n      def __init__(self, meetings_api: MeetingAPIProtocol) -&gt; None:\n          self._meetings_api = meetings_api\n          self.events: list[Event] = []\n\n      @property\n      def events(self) -&gt; typing.List[events.Event]:\n          return self._events\n\n      async def handle(self, request: JoinMeetingCommand) -&gt; None:\n          await self._meetings_api.join_user(request.user_id, request.meeting_id)\n\n\nclass SyncJoinMeetingCommandHandler(SyncRequestHandler[JoinMeetingCommand, None]):\n\n      def __init__(self, meetings_api: MeetingAPIProtocol) -&gt; None:\n          self._meetings_api = meetings_api\n          self.events: list[Event] = []\n\n      @property\n      def events(self) -&gt; typing.List[events.Event]:\n          return self._events\n\n      def handle(self, request: JoinMeetingCommand) -&gt; None:\n          # do some sync logic\n          ...\n</code></pre>"},{"location":"request_handler/#query-handler","title":"Query Handler","text":"<p>Query Handler returns a representation of the requested data, for example, from the read model.</p> Info <p>The read model can be constructed based on domain events produced by the <code>Command Handler</code>.</p> <pre><code>from cqrs.requests.request_handler import RequestHandler\nfrom cqrs.events.event import Event\n\nclass ReadMeetingQueryHandler(RequestHandler[ReadMeetingQuery, ReadMeetingQueryResult]):\n\n      def __init__(self, meetings_api: MeetingAPIProtocol) -&gt; None:\n          self._meetings_api = meetings_api\n          self.events: list[Event] = []\n\n      @property\n      def events(self) -&gt; typing.List[events.Event]:\n          return self._events\n\n      async def handle(self, request: ReadMeetingQuery) -&gt; ReadMeetingQueryResult:\n          link = await self._meetings_api.get_link(request.meeting_id)\n          return ReadMeetingQueryResult(link=link, meeting_id=request.meeting_id)\n</code></pre> <p>A complete examples can be found here.</p>"},{"location":"examples/","title":"Examples","text":"<p>This section contains practical examples and tutorials for using Python CQRS.</p>"},{"location":"examples/#available-examples","title":"Available Examples","text":"<ul> <li>Bootstrap Example \u2014 Learn how to set up a new project with Python CQRS</li> <li>Dependency Injection Example \u2014 Understand how to use DI with the framework</li> <li>Request Handler Example \u2014 See how to implement command and query handlers</li> </ul>"},{"location":"examples/#getting-started","title":"Getting Started","text":"<p>Each example is designed to be self-contained and can be run independently. They demonstrate best practices and common patterns used with Python CQRS.</p> <p>Choose an example that matches your use case and follow the step-by-step instructions to get started quickly.</p>"},{"location":"examples/bootstrap/","title":"Bootstrap","text":"<pre><code>import cqrs\n\ndef command_mapper(mapper: cqrs.RequestMap) -&gt; None: # (2)\n    mapper.bind(JoinMeetingCommand, JoinMeetingCommandHandler)\n\ndef query_mapper(mapper: cqrs.RequestMap) -&gt; None: # (3)\n    mapper.bind(ReadMeetingQuery, ReadMeetingQueryHandler)\n</code></pre>"},{"location":"examples/di/","title":"DI Examples","text":"<p>This page contains comprehensive examples of using Dependency Injection with <code>python-cqrs</code>, including production and test configurations.</p>"},{"location":"examples/di/#production-dependencies-setup","title":"Production Dependencies Setup","text":"<pre><code># app/dependencies.py\nimport di\nfrom di import Container\nfrom di.dependent import Dependent\nfrom cqrs import OutboxedEventRepository, SqlAlchemyOutboxedEventRepository\nfrom app.services import (\n    MeetingAPIProtocol, \n    MeetingAPIImplementation,\n    EmailServiceProtocol,\n    SMTPEmailService,\n    DatabaseConnection,\n    PostgreSQLConnection\n)\nfrom app.repositories import UserRepository, UserRepositoryProtocol\n\ndef setup_production_di() -&gt; Container:\n    \"\"\"Setup DI container for production environment.\"\"\"\n    container = Container()\n\n    # Database connection\n    container.bind(\n        di.bind_by_type(\n            Dependent(\n                lambda: PostgreSQLConnection(\n                    host=\"prod-db.example.com\",\n                    port=5432,\n                    database=\"meetings_db\",\n                    username=\"app_user\",\n                    password=\"secure_password\"\n                ),\n                scope=\"singleton\"\n            ),\n            DatabaseConnection\n        )\n    )\n\n    # Repository implementations\n    container.bind(\n        di.bind_by_type(\n            Dependent(SqlAlchemyOutboxedEventRepository, scope=\"request\"),\n            OutboxedEventRepository\n        )\n    )\n\n    container.bind(\n        di.bind_by_type(\n            Dependent(UserRepository, scope=\"request\"),\n            UserRepositoryProtocol\n        )\n    )\n\n    # Service implementations\n    container.bind(\n        di.bind_by_type(\n            Dependent(MeetingAPIImplementation, scope=\"request\"),\n            MeetingAPIProtocol\n        )\n    )\n\n    container.bind(\n        di.bind_by_type(\n            Dependent(\n                lambda: SMTPEmailService(\n                    smtp_host=\"smtp.example.com\",\n                    smtp_port=587,\n                    username=\"noreply@example.com\",\n                    password=\"email_password\"\n                ),\n                scope=\"singleton\"\n            ),\n            EmailServiceProtocol\n        )\n    )\n\n    return container\n</code></pre>"},{"location":"examples/di/#test-dependencies-setup","title":"Test Dependencies Setup","text":"<pre><code># tests/dependencies.py\nimport di\nfrom di import Container\nfrom di.dependent import Dependent\nfrom unittest.mock import Mock, AsyncMock\nfrom cqrs import OutboxedEventRepository\nfrom app.services import (\n    MeetingAPIProtocol, \n    EmailServiceProtocol,\n    DatabaseConnection\n)\nfrom app.repositories import UserRepositoryProtocol\n\ndef setup_test_di() -&gt; Container:\n    \"\"\"Setup DI container for testing environment.\"\"\"\n    container = Container()\n\n    # Mock database connection\n    mock_db = Mock(spec=DatabaseConnection)\n    mock_db.connect.return_value = None\n    mock_db.disconnect.return_value = None\n\n    container.bind(\n        di.bind_by_type(\n            Dependent(lambda: mock_db, scope=\"singleton\"),\n            DatabaseConnection\n        )\n    )\n\n    # Mock repository\n    mock_outbox_repo = Mock(spec=OutboxedEventRepository)\n    mock_outbox_repo.save_event = AsyncMock()\n    mock_outbox_repo.get_pending_events = AsyncMock(return_value=[])\n\n    container.bind(\n        di.bind_by_type(\n            Dependent(lambda: mock_outbox_repo, scope=\"request\"),\n            OutboxedEventRepository\n        )\n    )\n\n    # Mock user repository\n    mock_user_repo = Mock(spec=UserRepositoryProtocol)\n    mock_user_repo.get_user = AsyncMock()\n    mock_user_repo.save_user = AsyncMock()\n\n    container.bind(\n        di.bind_by_type(\n            Dependent(lambda: mock_user_repo, scope=\"request\"),\n            UserRepositoryProtocol\n        )\n    )\n\n    # Mock meeting API\n    mock_meeting_api = Mock(spec=MeetingAPIProtocol)\n    mock_meeting_api.join_user = AsyncMock()\n    mock_meeting_api.leave_user = AsyncMock()\n    mock_meeting_api.get_meeting_info = AsyncMock()\n\n    container.bind(\n        di.bind_by_type(\n            Dependent(lambda: mock_meeting_api, scope=\"request\"),\n            MeetingAPIProtocol\n        )\n    )\n\n    # Mock email service\n    mock_email_service = Mock(spec=EmailServiceProtocol)\n    mock_email_service.send_email = AsyncMock()\n\n    container.bind(\n        di.bind_by_type(\n            Dependent(lambda: mock_email_service, scope=\"singleton\"),\n            EmailServiceProtocol\n        )\n    )\n\n    return container\n</code></pre>"},{"location":"examples/di/#command-handler-with-dependencies","title":"Command Handler with Dependencies","text":"<pre><code># app/handlers/meeting_handlers.py\nfrom cqrs.requests import RequestHandler\nfrom cqrs.events import Event\nfrom app.services import MeetingAPIProtocol, EmailServiceProtocol\nfrom app.repositories import UserRepositoryProtocol\nfrom app.models import JoinMeetingCommand, UserJoinedMeetingEvent\n\nclass JoinMeetingCommandHandler(RequestHandler[JoinMeetingCommand, None]):\n\n    def __init__(\n        self, \n        meetings_api: MeetingAPIProtocol,\n        email_service: EmailServiceProtocol,\n        user_repo: UserRepositoryProtocol\n    ) -&gt; None:\n        self._meetings_api = meetings_api\n        self._email_service = email_service\n        self._user_repo = user_repo\n        self._events: list[Event] = []\n\n    @property\n    def events(self) -&gt; list[Event]:\n        return self._events\n\n    async def handle(self, request: JoinMeetingCommand) -&gt; None:\n        # Get user information\n        user = await self._user_repo.get_user(request.user_id)\n\n        # Join the meeting\n        await self._meetings_api.join_user(request.user_id, request.meeting_id)\n\n        # Send notification email\n        await self._email_service.send_email(\n            to=user.email,\n            subject=\"Meeting Joined\",\n            body=f\"You have successfully joined meeting {request.meeting_id}\"\n        )\n\n        # Add domain event\n        self._events.append(\n            UserJoinedMeetingEvent(\n                user_id=request.user_id,\n                meeting_id=request.meeting_id,\n                joined_at=datetime.utcnow()\n            )\n        )\n</code></pre>"},{"location":"examples/di/#query-handler-with-dependencies","title":"Query Handler with Dependencies","text":"<pre><code># app/handlers/meeting_queries.py\nfrom cqrs.requests import RequestHandler\nfrom app.services import MeetingAPIProtocol\nfrom app.models import GetMeetingInfoQuery, GetMeetingInfoResult\n\nclass GetMeetingInfoQueryHandler(RequestHandler[GetMeetingInfoQuery, GetMeetingInfoResult]):\n\n    def __init__(self, meetings_api: MeetingAPIProtocol) -&gt; None:\n        self._meetings_api = meetings_api\n\n    @property\n    def events(self) -&gt; list[Event]:\n        return []\n\n    async def handle(self, request: GetMeetingInfoQuery) -&gt; GetMeetingInfoResult:\n        meeting_info = await self._meetings_api.get_meeting_info(request.meeting_id)\n\n        return GetMeetingInfoResult(\n            meeting_id=meeting_info.id,\n            title=meeting_info.title,\n            participants=meeting_info.participants,\n            start_time=meeting_info.start_time,\n            end_time=meeting_info.end_time\n        )\n</code></pre>"},{"location":"examples/di/#bootstrap-with-environment-specific-di","title":"Bootstrap with Environment-Specific DI","text":"<pre><code># app/bootstrap.py\nimport os\nimport functools\nfrom cqrs.requests import bootstrap as request_bootstrap\nfrom app import dependencies, mapping, orm\n\ndef get_environment():\n    \"\"\"Get current environment from environment variable.\"\"\"\n    return os.getenv(\"ENVIRONMENT\", \"development\")\n\n@functools.lru_cache\ndef mediator_factory():\n    \"\"\"Factory function that creates mediator with environment-specific DI.\"\"\"\n    environment = get_environment()\n\n    if environment == \"test\":\n        di_container = dependencies.setup_test_di()\n    else:\n        di_container = dependencies.setup_production_di()\n\n    return request_bootstrap.bootstrap(\n        di_container=di_container,\n        commands_mapper=mapping.init_commands,\n        queries_mapper=mapping.init_queries,\n        domain_events_mapper=mapping.init_events,\n        on_startup=[orm.init_store_event_mapper],\n    )\n</code></pre>"},{"location":"examples/di/#pytest-test-examples","title":"Pytest Test Examples","text":"<pre><code># tests/test_meeting_handlers.py\nimport pytest\nfrom unittest.mock import AsyncMock, Mock\nfrom app.handlers.meeting_handlers import JoinMeetingCommandHandler\nfrom app.models import JoinMeetingCommand, User\nfrom tests.dependencies import setup_test_di\n\n@pytest.fixture\ndef test_container():\n    \"\"\"Create test DI container with mocked dependencies.\"\"\"\n    return setup_test_di()\n\n@pytest.fixture\ndef mock_user():\n    \"\"\"Create mock user for testing.\"\"\"\n    user = Mock(spec=User)\n    user.id = \"user123\"\n    user.email = \"test@example.com\"\n    user.name = \"Test User\"\n    return user\n\n@pytest.fixture\ndef join_meeting_command():\n    \"\"\"Create test command.\"\"\"\n    return JoinMeetingCommand(\n        user_id=\"user123\",\n        meeting_id=\"meeting456\"\n    )\n\n@pytest.mark.asyncio\nasync def test_join_meeting_command_success(test_container, mock_user, join_meeting_command):\n    \"\"\"Test successful meeting join.\"\"\"\n    # Get mocked dependencies\n    user_repo = test_container.solve(UserRepositoryProtocol)\n    meeting_api = test_container.solve(MeetingAPIProtocol)\n    email_service = test_container.solve(EmailServiceProtocol)\n\n    # Setup mock responses\n    user_repo.get_user.return_value = mock_user\n    meeting_api.join_user.return_value = None\n    email_service.send_email.return_value = None\n\n    # Create handler\n    handler = test_container.solve(JoinMeetingCommandHandler)\n\n    # Execute command\n    await handler.handle(join_meeting_command)\n\n    # Verify interactions\n    user_repo.get_user.assert_called_once_with(\"user123\")\n    meeting_api.join_user.assert_called_once_with(\"user123\", \"meeting456\")\n    email_service.send_email.assert_called_once_with(\n        to=\"test@example.com\",\n        subject=\"Meeting Joined\",\n        body=\"You have successfully joined meeting meeting456\"\n    )\n\n    # Verify events were created\n    assert len(handler.events) == 1\n    event = handler.events[0]\n    assert event.user_id == \"user123\"\n    assert event.meeting_id == \"meeting456\"\n\n@pytest.mark.asyncio\nasync def test_join_meeting_command_user_not_found(test_container, join_meeting_command):\n    \"\"\"Test meeting join when user is not found.\"\"\"\n    # Get mocked dependencies\n    user_repo = test_container.solve(UserRepositoryProtocol)\n    meeting_api = test_container.solve(MeetingAPIProtocol)\n    email_service = test_container.solve(EmailServiceProtocol)\n\n    # Setup mock to raise exception\n    user_repo.get_user.side_effect = UserNotFoundError(\"User not found\")\n\n    # Create handler\n    handler = test_container.solve(JoinMeetingCommandHandler)\n\n    # Execute command and expect exception\n    with pytest.raises(UserNotFoundError):\n        await handler.handle(join_meeting_command)\n\n    # Verify that meeting API was not called\n    meeting_api.join_user.assert_not_called()\n    email_service.send_email.assert_not_called()\n\n@pytest.mark.asyncio\nasync def test_join_meeting_command_email_failure(test_container, mock_user, join_meeting_command):\n    \"\"\"Test meeting join when email sending fails.\"\"\"\n    # Get mocked dependencies\n    user_repo = test_container.solve(UserRepositoryProtocol)\n    meeting_api = test_container.solve(MeetingAPIProtocol)\n    email_service = test_container.solve(EmailServiceProtocol)\n\n    # Setup mock responses\n    user_repo.get_user.return_value = mock_user\n    meeting_api.join_user.return_value = None\n    email_service.send_email.side_effect = EmailServiceError(\"SMTP connection failed\")\n\n    # Create handler\n    handler = test_container.solve(JoinMeetingCommandHandler)\n\n    # Execute command and expect exception\n    with pytest.raises(EmailServiceError):\n        await handler.handle(join_meeting_command)\n\n    # Verify that user was retrieved and meeting API was called\n    user_repo.get_user.assert_called_once_with(\"user123\")\n    meeting_api.join_user.assert_called_once_with(\"user123\", \"meeting456\")\n\n@pytest.mark.asyncio\nasync def test_get_meeting_info_query(test_container):\n    \"\"\"Test meeting info query.\"\"\"\n    # Get mocked dependencies\n    meeting_api = test_container.solve(MeetingAPIProtocol)\n\n    # Setup mock response\n    mock_meeting_info = Mock()\n    mock_meeting_info.id = \"meeting456\"\n    mock_meeting_info.title = \"Team Standup\"\n    mock_meeting_info.participants = [\"user123\", \"user456\"]\n    mock_meeting_info.start_time = datetime(2024, 1, 15, 10, 0)\n    mock_meeting_info.end_time = datetime(2024, 1, 15, 10, 30)\n\n    meeting_api.get_meeting_info.return_value = mock_meeting_info\n\n    # Create handler\n    handler = test_container.solve(GetMeetingInfoQueryHandler)\n\n    # Execute query\n    query = GetMeetingInfoQuery(meeting_id=\"meeting456\")\n    result = await handler.handle(query)\n\n    # Verify result\n    assert result.meeting_id == \"meeting456\"\n    assert result.title == \"Team Standup\"\n    assert result.participants == [\"user123\", \"user456\"]\n\n    # Verify API was called\n    meeting_api.get_meeting_info.assert_called_once_with(\"meeting456\")\n</code></pre>"},{"location":"examples/di/#integration-test-example","title":"Integration Test Example","text":"<pre><code># tests/test_integration.py\nimport pytest\nfrom app.bootstrap import mediator_factory\nfrom app.models import JoinMeetingCommand, GetMeetingInfoQuery\n\n@pytest.fixture\ndef test_mediator():\n    \"\"\"Create mediator with test dependencies.\"\"\"\n    # Set test environment\n    import os\n    os.environ[\"ENVIRONMENT\"] = \"test\"\n\n    # Clear cache to get fresh mediator\n    mediator_factory.cache_clear()\n\n    return mediator_factory()\n\n@pytest.mark.asyncio\nasync def test_meeting_workflow_integration(test_mediator):\n    \"\"\"Test complete meeting workflow.\"\"\"\n    # Join meeting\n    join_command = JoinMeetingCommand(\n        user_id=\"user123\",\n        meeting_id=\"meeting456\"\n    )\n\n    await test_mediator.send(join_command)\n\n    # Get meeting info\n    info_query = GetMeetingInfoQuery(meeting_id=\"meeting456\")\n    meeting_info = await test_mediator.send(info_query)\n\n    # Verify meeting info\n    assert meeting_info.meeting_id == \"meeting456\"\n    assert \"user123\" in meeting_info.participants\n</code></pre>"},{"location":"examples/request_handler/","title":"Request Handler","text":"<p>This page demonstrates comprehensive examples of request handlers with advanced patterns including event handling, validation, error management, and WebSocket integration.</p>"},{"location":"examples/request_handler/#basic-example","title":"Basic Example","text":"<pre><code>import asyncio\nimport logging\nimport typing\nfrom collections import defaultdict\n\nimport di\n\nimport cqrs\nfrom cqrs.requests import bootstrap\n\nlogging.basicConfig(level=logging.DEBUG)\n\nSTORAGE = defaultdict[str, typing.List[str]](lambda: [])\n\n\nclass JoinMeetingCommand(cqrs.Request):\n    user_id: str\n    meeting_id: str\n\n\nclass ReadMeetingQuery(cqrs.Request):\n    meeting_id: str\n\n\nclass ReadMeetingQueryResult(cqrs.Response):\n    users: list[str]\n\n\nclass JoinMeetingCommandHandler(cqrs.RequestHandler[JoinMeetingCommand, None]):\n    @property\n    def events(self):\n        return []\n\n    async def handle(self, request: JoinMeetingCommand) -&gt; None:\n        STORAGE[request.meeting_id].append(request.user_id)\n        print(f\"User {request.user_id} joined meeting {request.meeting_id}\")\n\n\nclass ReadMeetingQueryHandler(\n    cqrs.RequestHandler[ReadMeetingQuery, ReadMeetingQueryResult],\n):\n    @property\n    def events(self):\n        return []\n\n    async def handle(self, request: ReadMeetingQuery) -&gt; ReadMeetingQueryResult:\n        return ReadMeetingQueryResult(users=STORAGE[request.meeting_id])\n\n\ndef command_mapper(mapper: cqrs.RequestMap) -&gt; None:\n    mapper.bind(JoinMeetingCommand, JoinMeetingCommandHandler)\n\n\ndef query_mapper(mapper: cqrs.RequestMap) -&gt; None:\n    mapper.bind(ReadMeetingQuery, ReadMeetingQueryHandler)\n\n\nasync def main():\n    mediator = bootstrap.bootstrap(\n        di_container=di.Container(),\n        queries_mapper=query_mapper,\n        commands_mapper=command_mapper,\n    )\n    await mediator.send(JoinMeetingCommand(user_id=\"1\", meeting_id=\"1\"))\n    await mediator.send(JoinMeetingCommand(user_id=\"2\", meeting_id=\"1\"))\n    await mediator.send(JoinMeetingCommand(user_id=\"3\", meeting_id=\"1\"))\n    await mediator.send(JoinMeetingCommand(user_id=\"4\", meeting_id=\"1\"))\n    users_in_room = await mediator.send(ReadMeetingQuery(meeting_id=\"1\"))\n    print(\"There are {} users in the room\".format(len(users_in_room.users)))\n    assert len(users_in_room.users) == 4\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/request_handler/#advanced-example-with-events-and-validation","title":"Advanced Example with Events and Validation","text":"<pre><code>import asyncio\nimport logging\nfrom datetime import datetime\nfrom typing import Optional, List, Protocol\nfrom uuid import uuid4\n\nimport di\nimport cqrs\nfrom cqrs.requests import bootstrap\nfrom cqrs.events import Event, EventMap\nfrom pydantic import BaseModel, Field, validator\n\n# Domain Models\nclass User(BaseModel):\n    id: str\n    username: str\n    email: str\n    is_online: bool = False\n\nclass ChatRoom(BaseModel):\n    id: str\n    name: str\n    participants: List[str] = []\n    created_at: datetime\n    is_active: bool = True\n\n# Commands\nclass CreateChatRoomCommand(cqrs.Request):\n    name: str = Field(..., min_length=1, max_length=100)\n    creator_id: str\n    description: Optional[str] = None\n\nclass JoinChatRoomCommand(cqrs.Request):\n    user_id: str\n    room_id: str\n\nclass SendMessageCommand(cqrs.Request):\n    user_id: str\n    room_id: str\n    content: str = Field(..., min_length=1, max_length=1000)\n    message_type: str = \"text\"\n\n    @validator('content')\n    def validate_content(cls, v):\n        if not v.strip():\n            raise ValueError('Message content cannot be empty')\n        return v.strip()\n\nclass LeaveChatRoomCommand(cqrs.Request):\n    user_id: str\n    room_id: str\n\n# Queries\nclass GetChatRoomQuery(cqrs.Request):\n    room_id: str\n\nclass GetUserChatRoomsQuery(cqrs.Request):\n    user_id: str\n\nclass GetChatRoomMessagesQuery(cqrs.Request):\n    room_id: str\n    limit: int = 50\n    offset: int = 0\n\n# Responses\nclass CreateChatRoomResponse(cqrs.Response):\n    room_id: str\n    room_name: str\n    creator_id: str\n\nclass JoinChatRoomResponse(cqrs.Response):\n    user_id: str\n    room_id: str\n    joined_at: datetime\n\nclass SendMessageResponse(cqrs.Response):\n    message_id: str\n    user_id: str\n    room_id: str\n    timestamp: datetime\n\nclass ChatRoomResponse(cqrs.Response):\n    id: str\n    name: str\n    participants: List[str]\n    participant_count: int\n    is_active: bool\n\nclass MessageResponse(cqrs.Response):\n    id: str\n    user_id: str\n    content: str\n    message_type: str\n    timestamp: datetime\n    room_id: str\n\n# Events\nclass ChatRoomCreatedEvent(Event):\n    room_id: str\n    creator_id: str\n    room_name: str\n    created_at: datetime\n\nclass UserJoinedRoomEvent(Event):\n    user_id: str\n    room_id: str\n    joined_at: datetime\n\nclass UserLeftRoomEvent(Event):\n    user_id: str\n    room_id: str\n    left_at: datetime\n\nclass MessageSentEvent(Event):\n    message_id: str\n    user_id: str\n    room_id: str\n    content: str\n    message_type: str\n    timestamp: datetime\n\n# In-memory storage (in real app, use database)\nCHAT_ROOMS: dict[str, ChatRoom] = {}\nMESSAGES: dict[str, List[MessageResponse]] = defaultdict(list)\nUSER_ROOMS: dict[str, List[str]] = defaultdict(list)\n\n# Protocols for Dependencies\nclass WebSocketManagerProtocol(Protocol):\n    async def add_connection(self, user_id: str, websocket) -&gt; None: ...\n    async def remove_connection(self, user_id: str, websocket) -&gt; None: ...\n    async def add_to_room(self, user_id: str, room_id: str, websocket) -&gt; None: ...\n    async def broadcast_to_user(self, user_id: str, message: dict) -&gt; None: ...\n    async def broadcast_to_room(self, room_id: str, message: dict) -&gt; None: ...\n    async def broadcast_to_all(self, message: dict) -&gt; None: ...\n\n# Command Handlers\nclass CreateChatRoomHandler(cqrs.RequestHandler[CreateChatRoomCommand, CreateChatRoomResponse]):\n    def __init__(self, websocket_manager: WebSocketManagerProtocol):\n        self._websocket_manager = websocket_manager\n        self._events: List[Event] = []\n\n    @property\n    def events(self) -&gt; List[Event]:\n        return self._events\n\n    async def handle(self, request: CreateChatRoomCommand) -&gt; CreateChatRoomResponse:\n        room_id = str(uuid4())\n\n        # Create chat room\n        room = ChatRoom(\n            id=room_id,\n            name=request.name,\n            participants=[request.creator_id],\n            created_at=datetime.utcnow()\n        )\n        CHAT_ROOMS[room_id] = room\n        USER_ROOMS[request.creator_id].append(room_id)\n\n        # Emit domain event\n        self._events.append(ChatRoomCreatedEvent(\n            room_id=room_id,\n            creator_id=request.creator_id,\n            room_name=request.name,\n            created_at=room.created_at\n        ))\n\n        # Notify via WebSocket\n        await self._websocket_manager.broadcast_to_user(\n            request.creator_id,\n            {\"type\": \"room_created\", \"room_id\": room_id, \"room_name\": request.name}\n        )\n\n        return CreateChatRoomResponse(\n            room_id=room_id,\n            room_name=request.name,\n            creator_id=request.creator_id\n        )\n\nclass JoinChatRoomHandler(cqrs.RequestHandler[JoinChatRoomCommand, JoinChatRoomResponse]):\n    def __init__(self, websocket_manager: WebSocketManagerProtocol):\n        self._websocket_manager = websocket_manager\n        self._events: List[Event] = []\n\n    @property\n    def events(self) -&gt; List[Event]:\n        return self._events\n\n    async def handle(self, request: JoinChatRoomCommand) -&gt; JoinChatRoomResponse:\n        if request.room_id not in CHAT_ROOMS:\n            raise ValueError(f\"Chat room {request.room_id} not found\")\n\n        room = CHAT_ROOMS[request.room_id]\n        if not room.is_active:\n            raise ValueError(f\"Chat room {request.room_id} is not active\")\n\n        if request.user_id not in room.participants:\n            room.participants.append(request.user_id)\n            USER_ROOMS[request.user_id].append(request.room_id)\n\n            # Emit domain event\n            self._events.append(UserJoinedRoomEvent(\n                user_id=request.user_id,\n                room_id=request.room_id,\n                joined_at=datetime.utcnow()\n            ))\n\n            # Notify all participants\n            await self._websocket_manager.broadcast_to_room(\n                request.room_id,\n                {\"type\": \"user_joined\", \"user_id\": request.user_id, \"room_id\": request.room_id}\n            )\n\n            return JoinChatRoomResponse(\n                user_id=request.user_id,\n                room_id=request.room_id,\n                joined_at=datetime.utcnow()\n            )\n\nclass SendMessageHandler(cqrs.RequestHandler[SendMessageCommand, SendMessageResponse]):\n    def __init__(self, websocket_manager: WebSocketManagerProtocol):\n        self._websocket_manager = websocket_manager\n        self._events: List[Event] = []\n\n    @property\n    def events(self) -&gt; List[Event]:\n        return self._events\n\n    async def handle(self, request: SendMessageCommand) -&gt; SendMessageResponse:\n        if request.room_id not in CHAT_ROOMS:\n            raise ValueError(f\"Chat room {request.room_id} not found\")\n\n        room = CHAT_ROOMS[request.room_id]\n        if request.user_id not in room.participants:\n            raise ValueError(f\"User {request.user_id} is not in room {request.room_id}\")\n\n        message_id = str(uuid4())\n        message = MessageResponse(\n            id=message_id,\n            user_id=request.user_id,\n            content=request.content,\n            message_type=request.message_type,\n            timestamp=datetime.utcnow(),\n            room_id=request.room_id\n        )\n\n        MESSAGES[request.room_id].append(message)\n\n        # Emit domain event\n        self._events.append(MessageSentEvent(\n            message_id=message_id,\n            user_id=request.user_id,\n            room_id=request.room_id,\n            content=request.content,\n            message_type=request.message_type,\n            timestamp=message.timestamp\n        ))\n\n        # Broadcast to room participants\n        await self._websocket_manager.broadcast_to_room(\n            request.room_id,\n            {\n                \"type\": \"message\",\n                \"message_id\": message_id,\n                \"user_id\": request.user_id,\n                \"content\": request.content,\n                \"message_type\": request.message_type,\n                \"timestamp\": message.timestamp.isoformat()\n            }\n        )\n\n        return SendMessageResponse(\n            message_id=message_id,\n            user_id=request.user_id,\n            room_id=request.room_id,\n            timestamp=message.timestamp\n        )\n\n# Query Handlers\nclass GetChatRoomHandler(cqrs.RequestHandler[GetChatRoomQuery, ChatRoomResponse]):\n    @property\n    def events(self) -&gt; List[Event]:\n        return []\n\n    async def handle(self, request: GetChatRoomQuery) -&gt; ChatRoomResponse:\n        if request.room_id not in CHAT_ROOMS:\n            raise ValueError(f\"Chat room {request.room_id} not found\")\n\n        room = CHAT_ROOMS[request.room_id]\n        return ChatRoomResponse(\n            id=room.id,\n            name=room.name,\n            participants=room.participants,\n            participant_count=len(room.participants),\n            is_active=room.is_active\n        )\n\nclass GetUserChatRoomsHandler(cqrs.RequestHandler[GetUserChatRoomsQuery, List[ChatRoomResponse]]):\n    @property\n    def events(self) -&gt; List[Event]:\n        return []\n\n    async def handle(self, request: GetUserChatRoomsQuery) -&gt; List[ChatRoomResponse]:\n        user_room_ids = USER_ROOMS.get(request.user_id, [])\n        rooms = []\n\n        for room_id in user_room_ids:\n            if room_id in CHAT_ROOMS:\n                room = CHAT_ROOMS[room_id]\n                rooms.append(ChatRoomResponse(\n                    id=room.id,\n                    name=room.name,\n                    participants=room.participants,\n                    participant_count=len(room.participants),\n                    is_active=room.is_active\n                ))\n\n        return rooms\n\nclass GetChatRoomMessagesHandler(cqrs.RequestHandler[GetChatRoomMessagesQuery, List[MessageResponse]]):\n    @property\n    def events(self) -&gt; List[Event]:\n        return []\n\n    async def handle(self, request: GetChatRoomMessagesQuery) -&gt; List[MessageResponse]:\n        if request.room_id not in MESSAGES:\n            return []\n\n        messages = MESSAGES[request.room_id]\n        # Return messages in reverse chronological order (newest first)\n        start = len(messages) - request.offset - request.limit\n        end = len(messages) - request.offset\n\n        return messages[max(0, start):max(0, end)][::-1]\n\n# Event Handlers\nclass ChatRoomCreatedEventHandler(cqrs.EventHandler[ChatRoomCreatedEvent]):\n    def __init__(self, websocket_manager: WebSocketManagerProtocol):\n        self._websocket_manager = websocket_manager\n\n    async def handle(self, event: ChatRoomCreatedEvent) -&gt; None:\n        # Notify all online users about new room\n        await self._websocket_manager.broadcast_to_all({\n            \"type\": \"room_created\",\n            \"room_id\": event.room_id,\n            \"room_name\": event.room_name,\n            \"creator_id\": event.creator_id,\n            \"created_at\": event.created_at.isoformat()\n        })\n        print(f\"Event: Room '{event.room_name}' created by {event.creator_id}\")\n\nclass UserJoinedRoomEventHandler(cqrs.EventHandler[UserJoinedRoomEvent]):\n    def __init__(self, websocket_manager: WebSocketManagerProtocol):\n        self._websocket_manager = websocket_manager\n\n    async def handle(self, event: UserJoinedRoomEvent) -&gt; None:\n        # Update room participant count\n        await self._websocket_manager.broadcast_to_room(\n            event.room_id,\n            {\n                \"type\": \"user_joined\",\n                \"user_id\": event.user_id,\n                \"room_id\": event.room_id,\n                \"joined_at\": event.joined_at.isoformat()\n            }\n        )\n        print(f\"Event: User {event.user_id} joined room {event.room_id}\")\n\nclass UserLeftRoomEventHandler(cqrs.EventHandler[UserLeftRoomEvent]):\n    def __init__(self, websocket_manager: WebSocketManagerProtocol):\n        self._websocket_manager = websocket_manager\n\n    async def handle(self, event: UserLeftRoomEvent) -&gt; None:\n        # Notify remaining participants\n        await self._websocket_manager.broadcast_to_room(\n            event.room_id,\n            {\n                \"type\": \"user_left\",\n                \"user_id\": event.user_id,\n                \"room_id\": event.room_id,\n                \"left_at\": event.left_at.isoformat()\n            }\n        )\n        print(f\"Event: User {event.user_id} left room {event.room_id}\")\n\nclass MessageSentEventHandler(cqrs.EventHandler[MessageSentEvent]):\n    def __init__(self, websocket_manager: WebSocketManagerProtocol):\n        self._websocket_manager = websocket_manager\n\n    async def handle(self, event: MessageSentEvent) -&gt; None:\n        # Real-time message broadcasting\n        await self._websocket_manager.broadcast_to_room(\n            event.room_id,\n            {\n                \"type\": \"message_sent\",\n                \"message_id\": event.message_id,\n                \"user_id\": event.user_id,\n                \"room_id\": event.room_id,\n                \"content\": event.content,\n                \"message_type\": event.message_type,\n                \"timestamp\": event.timestamp.isoformat()\n            }\n        )\n        print(f\"Event: Message {event.message_id} sent by {event.user_id} in room {event.room_id}\")\n\n# WebSocket Manager (simplified)\nclass WebSocketManager(WebSocketManagerProtocol):\n    def __init__(self):\n        self._connections: dict[str, set] = defaultdict(set)\n        self._room_connections: dict[str, set] = defaultdict(set)\n\n    async def add_connection(self, user_id: str, websocket):\n        self._connections[user_id].add(websocket)\n\n    async def remove_connection(self, user_id: str, websocket):\n        self._connections[user_id].discard(websocket)\n\n    async def add_to_room(self, user_id: str, room_id: str, websocket):\n        self._room_connections[room_id].add(websocket)\n\n    async def broadcast_to_user(self, user_id: str, message: dict):\n        for websocket in self._connections[user_id]:\n            try:\n                await websocket.send_json(message)\n            except:\n                # Handle disconnected websockets\n                pass\n\n    async def broadcast_to_room(self, room_id: str, message: dict):\n        for websocket in self._room_connections[room_id]:\n            try:\n                await websocket.send_json(message)\n            except:\n                # Handle disconnected websockets\n                pass\n\n    async def broadcast_to_all(self, message: dict):\n        for user_connections in self._connections.values():\n            for websocket in user_connections:\n                try:\n                    await websocket.send_json(message)\n                except:\n                    # Handle disconnected websockets\n                    pass\n\n# Mappers\ndef command_mapper(mapper: cqrs.RequestMap) -&gt; None:\n    mapper.bind(CreateChatRoomCommand, CreateChatRoomHandler)\n    mapper.bind(JoinChatRoomCommand, JoinChatRoomHandler)\n    mapper.bind(SendMessageCommand, SendMessageHandler)\n    # LeaveChatRoomCommand would need its own handler implementation\n\ndef query_mapper(mapper: cqrs.RequestMap) -&gt; None:\n    mapper.bind(GetChatRoomQuery, GetChatRoomHandler)\n    mapper.bind(GetUserChatRoomsQuery, GetUserChatRoomsHandler)\n    mapper.bind(GetChatRoomMessagesQuery, GetChatRoomMessagesHandler)\n\ndef event_mapper(mapper: cqrs.EventMap) -&gt; None:\n    mapper.bind(ChatRoomCreatedEvent, ChatRoomCreatedEventHandler)\n    mapper.bind(UserJoinedRoomEvent, UserJoinedRoomEventHandler)\n    mapper.bind(UserLeftRoomEvent, UserLeftRoomEventHandler)\n    mapper.bind(MessageSentEvent, MessageSentEventHandler)\n\n# Bootstrap with DI\ndef setup_di() -&gt; di.Container:\n    container = di.Container()\n    websocket_manager = WebSocketManager()\n\n    container.bind(\n        di.bind_by_type(\n            di.Dependent(lambda: websocket_manager, scope=\"singleton\"),\n            WebSocketManager\n        )\n    )\n\n    return container\n\nasync def main():\n    mediator = bootstrap.bootstrap(\n        di_container=setup_di(),\n        queries_mapper=query_mapper,\n        commands_mapper=command_mapper,\n        domain_events_mapper=event_mapper,\n    )\n\n    # Create a chat room\n    room_result = await mediator.send(CreateChatRoomCommand(\n        name=\"General Chat\",\n        creator_id=\"user1\",\n        description=\"Main discussion room\"\n    ))\n    print(f\"Created room: {room_result.room_name} (ID: {room_result.room_id})\")\n\n    # Join users to the room\n    join_result1 = await mediator.send(JoinChatRoomCommand(user_id=\"user2\", room_id=room_result.room_id))\n    join_result2 = await mediator.send(JoinChatRoomCommand(user_id=\"user3\", room_id=room_result.room_id))\n    print(f\"Users joined: {join_result1.user_id}, {join_result2.user_id}\")\n\n    # Send messages\n    message_result1 = await mediator.send(SendMessageCommand(\n        user_id=\"user1\",\n        room_id=room_result.room_id,\n        content=\"Hello everyone!\"\n    ))\n\n    message_result2 = await mediator.send(SendMessageCommand(\n        user_id=\"user2\",\n        room_id=room_result.room_id,\n        content=\"Hi there!\"\n    ))\n    print(f\"Messages sent: {message_result1.message_id}, {message_result2.message_id}\")\n\n    # Query room info\n    room_info = await mediator.send(GetChatRoomQuery(room_id=room_result.room_id))\n    print(f\"Room: {room_info.name}, Participants: {room_info.participant_count}\")\n\n    # Get messages\n    messages = await mediator.send(GetChatRoomMessagesQuery(room_id=room_result.room_id, limit=10))\n    print(f\"Found {len(messages)} messages\")\n\n    # Get user's rooms\n    user_rooms = await mediator.send(GetUserChatRoomsQuery(user_id=\"user1\"))\n    print(f\"User1 is in {len(user_rooms)} rooms\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/request_handler/#key-concepts-demonstrated","title":"Key Concepts Demonstrated","text":""},{"location":"examples/request_handler/#1-domain-events-and-event-handlers","title":"1. Domain Events and Event Handlers","text":"<ul> <li><code>ChatRoomCreatedEvent</code>, <code>UserJoinedRoomEvent</code>, <code>MessageSentEvent</code></li> <li>Events are emitted by command handlers and processed by event handlers</li> <li>Event handlers handle side effects like notifications, logging, and real-time updates</li> <li>Enable loose coupling between different parts of the system</li> </ul>"},{"location":"examples/request_handler/#2-validation-and-error-handling","title":"2. Validation and Error Handling","text":"<ul> <li>Pydantic validators for input validation</li> <li>Custom business logic validation in handlers</li> <li>Proper error propagation with meaningful messages</li> </ul>"},{"location":"examples/request_handler/#3-dependency-injection","title":"3. Dependency Injection","text":"<ul> <li>WebSocket manager injected into handlers</li> <li>Clean separation of concerns</li> <li>Easy testing with mock dependencies</li> </ul>"},{"location":"examples/request_handler/#4-websocket-integration","title":"4. WebSocket Integration","text":"<ul> <li>Real-time communication with clients</li> <li>Room-based broadcasting</li> <li>User-specific notifications</li> </ul>"},{"location":"examples/request_handler/#5-complex-query-patterns","title":"5. Complex Query Patterns","text":"<ul> <li>Pagination support for messages</li> <li>User-specific room queries</li> <li>Aggregated data responses</li> </ul>"},{"location":"examples/request_handler/#6-event-driven-architecture","title":"6. Event-Driven Architecture","text":"<ul> <li>Command handlers emit events after successful operations</li> <li>Event handlers process events asynchronously</li> <li>Multiple event handlers can process the same event</li> <li>Real-time notifications and side effects</li> </ul> <p>This example shows how <code>python-cqrs</code> can be used to build complex, real-time applications with clean architecture, proper separation of concerns, event-driven design, and excellent testability.</p>"}]}